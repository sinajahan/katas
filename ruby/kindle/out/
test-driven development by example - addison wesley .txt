


Red/green/refactorthe TDD mantra. 



Test-driven development is a way of managing fear during programming. 



There certainly are programming tasks that can't be driven solely by tests (or at least, not yet). Security software and concurrency, for example, are two topics where TDD is insufficient 



only generalize code when we have two examples or more. We briefly ignore the duplication between test and model code. When the second example demands a more general solution, then and only then do we generalize. 



Wallace Stegner describes a character's workshop. Every item is perfectly in place, the floor is spotless, all is order and cleanliness. The character, however, has never made anything. "Preparing has been his life's work. He prepares, then he cleans up." 



done later. Finally, when the list is empty is a good time to review the design. Do the words and concepts play together? Is there duplication that is difficult to eliminate given the current design? 



There are roughly as many lines and functions in the test and functional code. 



Defect insertion is another way of evaluating test quality. The idea is simple: change the meaning of a line of code and a test should break. You can do this manually, or with a tool such as Jester 



Test coupling can have a subtle but very nasty effect, in situations in which the order of tests matters: If I run test A before test B, they both work, but if I run test B before test A, then test A fails. 



Duplication is always a bad thing, unless you look at it as motivation to find the missing design element. 



Martin Fowler said, "Never in the annals of software engineering was so much owed by so many to so few lines of code." 



I'm faced with a new programming language, I implement xUnit. By the time I have the first eight to ten tests running, I have explored many of the facilities I will be using in daily programming. 



The more stress you feel, the less testing you will do. The less testing you do, the more errors you will make. The more errors you make, the more stress you feel. Rinse and repeat. 



With automated tests, when I start to feel stress, I run the tests. Tests are the Programmer's Stone, transmuting fear into boredom. "No, I didn't break anything. The tests are all still green." The more stress I feel, the more I run the tests. 



was working with a couple of very sharp younger programmers on implementing in-memory transactions (a very cool technique every programming language should have). 



I had a similar list, but with a weekly or monthly scope, pinned on the wall. As soon as I had all that written down, I knew I wasn't going to forget something. 



What if we adopted the rule that we would always test first? 



When I test assert-first, I find it has a powerful simplifying effect. When you are writing a test, you are solving several problems at once, even if you no longer have to think about the implementation. 



Each test should represent one step toward your overall goal. 



What's the first thing you do when a defect is reported? Write the smallest possible test that fails and that, once run, will be repaired. Regression tests are tests that, with perfect foreknowledge, you would have written when coding originally. 



How do you leave a programming session when you're programming alone? Leave the last test broken. Richard Gabriel taught me the trick of finishing a writing session in midsentence. When you sit back down, 



Triangulate How do you most conservatively drive abstraction with tests? Abstract only when you have two or more examples. 



Wishing for white box testing is not a testing problem, it is a design problem. Anytime I want to use a variable as a way of checking to see whether code ran correctly or not, I have an opportunity to improve the design. If I give in to my fear and just check the variable, then I lose that opportunity. That said, if the design idea doesn't come, it doesn't come. I'll check the variable, shed a tear, make a note to come back on one of my smarter days, and move on. 



Module ("package" in Java) 



most of the problems we solve are generated by the tools we use, not by the external problem at hand.[1] Because of this, we can expect to find (and actually do find) common problems with common solutions even in the midst of an incredible diversity of external problem solving contexts. 



Null Object How do you represent special cases using objects? Create an object representing the special case. Give it the same protocol as the regular objects. 



Singleton How do you provide global variables in languages without global variables? Don't. Your programs will thank you for taking the time to think about design instead. 



"Write tests until fear is transformed into boredom." 



Sometimes, just to be extra careful, I will document the presence of, um, unusual behavior in external code with a test that will fail if the bug is ever fixed, er, the behavior is ever refined. 



I think about Mean Time Between Failures (MTBF) when I think about how many tests to write. 



If you are trying to get from an MTBF of 10 years to an MTBF of 100 years in your pacemaker, then tests for extremely unlikely conditions and combinations of conditions make sense, 



application test-driven development (ATDD). 



Good engineering is maybe 20 percent of a project's success. Bad engineering will certainly sink projects, but modest engineering can enable project success as long as the other 80 percent lines up right. From this perspective, TDD is overkill. 

- Your Bookmark Location 2590 | Added on Saturday, October 6, 2012 10:56:59 PM





My own practice of programming became much less stressful when I started with TDD. No longer did I have to worry about everything at once. 



Driven I used to call TDD "test-first programming." However, the opposite of "first" is "last," and lots of people test after they have programmed. There is a naming rule that the opposite of a name should be at least vaguely unsatisfactory. 
